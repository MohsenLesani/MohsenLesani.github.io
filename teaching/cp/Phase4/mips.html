<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html dir="ltr"><head>



  
  <meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>Compiler Project</title>
  

  
  
  <meta name="generator" content="LibreOffice 4.2.8.2 (Linux)">

  
  <meta name="created" content="0;0">

  
  <meta name="changed" content="20170313;185932962021360">

  
  <style type="text/css">
	<!--
		td p { color: #000000 }
		h1 { color: #000000 }
		p { color: #000000 }
		h2 { color: #000000 }
		h2.cjk { font-family: "Droid Sans Fallback" }
		h2.ctl { font-family: "FreeSans" }
		tt.cjk { font-family: "Droid Sans Fallback", monospace }

a:link {color: black;}      /* unvisited link */
       a:visited {color: black;}   /* visited link */
       a:hover {color: black;}     /* mouse over link */
       a:active {color: black;}    /* selected link */

.fixed-center-table { table-layout: fixed; width: 100%;
border-collapse: collapse;
}
.fixed-center-table td{ text-align: center;
}
col#middle-column { width: 650px;

	-->
}

	</style>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="qrichtext" content="1">

  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  
  <style type="text/css">
p, li { white-space: pre-wrap; <span style="font-family: monospace;">m</span></style>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="qrichtext" content="1"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><style type="text/css">
p, li { white-space: pre-wrap; }</style><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-type" content="text/html; charset=utf-8"></head><body style="background: transparent none repeat scroll 0% 50%; color: rgb(0, 0, 0); -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;"><table class="fixed-center-table" border="0">

  <thead> </thead><colgroup> <col> <col id="middle-column"> <col> </colgroup>
  <tbody>
    <tr>
      <td><br>
      </td>
      <td style="text-align: left; vertical-align: top;">
      <br>
<h3>MIPS Specification<br>
      </h3>

MIPS-I Assembly Language Instruction Set (Integer instructions only).<br>
      <br>
      <span style="font-weight: bold;">Arithmetic and Logical Instructions</span><br>
In all instructions below, src1, src2, and dest are general-purpose
registers. imm is a 16-bit immediate value embedded within the
instruction.<br>
      <br>
Put the sum of the integers from register Rsrc1 and Rsrc2 (or Imm) into register Rdest.<br>
add Rdest, Rsrc1, Rsrc2: Addition (with overflow)<br>
addi Rdest, Rsrc1, Imm: Addition immediate (with overflow)<br>
addu Rdest, Rsrc1, Rsrc2: Addition (without overflow)<br>
addiu Rdest, Rsrc1, Imm: Addition immediate (without overflow)<br>
      <br>
Put the logical AND of the integers from register Rsrc1 and Src2 (or Imm) into register Rdest.<br>
and Rdest, Rsrc1, Src2: AND<br>
andi Rdest, Rsrc1, Imm: AND Immediate<br>
      <br>
Divide the contents of the two registers. Leave the quotient in
register lo and the remainder in register hi. Note that if an operand
is negative, the remainder is nspecified by the MIPS architecture and
depends on the conventions of the machine on which the simulator is run.<br>
div Rsrc1, Rsrc2: Divide(with overflow)<br>
divu Rsrc1, Rsrc2: Divide(without overflow)<br>
      <br>
Multiply the contents of the two registers. Leave the low-order word of
the product in register lo and the high-word in register hi.<br>
mult Rsrc1, Rsrc2: Multiply<br>
multu Rsrc1, Rsrc2: Unsigned Multiply<br>
      <br>
Put the logical NOR of the integer from register Rsrc1 and Src2 into register Rdest.<br>
nor Rdest, Rsrc1, Src2: NOR<br>
      <br>
Put the logic OR of the integers from register Rsrc1 and Src2 (or Imm) into register Rdest.<br>
or Rdest, Rsrc1, Src2: OR<br>
ori Rdest, Rsrc1, Src2: OR Immediate<br>
      <br>
Shift the contents of register Rsrc1 left (right) by the distance
indicated by Src2 (Rsrc2) and put the result in register Rdest.<br>
sll Rdest, Rsrc1, Src2: Shift Left Logical<br>
sllv Rdest, Rsrc1, Rsrc2: Shift Left Logical Variable<br>
sra Rdest, Rsrc1, Src2: Shift Right Arithmetic<br>
srav Rdest, Rsrc1, Rsrc2: Shift Right Arithmetic Variable<br>
srl Rdest, Rsrc1, Src2: Shift Right Logical<br>
srlv Rdest, Rsrc1, Rsrc2: Shift Right Logical Variable<br>
      <br>
Put Rsrc1 - Rsrc2 into register Rdest.<br>
sub Rdest, Rsrc1, Rsrc2: Subtract (with overflow)<br>
subu Rdest, Rsrc1, Rsrc2: Subtract (without overflow)<br>
      <br>
Put the logical XOR of the integers from register Rsrc1 and Src2 (or Imm) into register Rdest.<br>
xor Rdest, Rsrc1, Src2: XOR<br>
xori Rdest, Rsrc1, Imm: XOR Immediate<br>
      <br>
      <span style="font-weight: bold;">Constant-Manipulating Instructions</span><br>
Load the lower halfword of the immediate imm into the upper halfword of
register Rdest. The lower bits of the register are set to 0.<br>
lui Rdest, imm: Load Upper Immediate<br>
      <br>
      <span style="font-weight: bold;">Comparison Instructions</span><br>
In all instructions below, Src2 can either be a register or an immediate value (a 16-bit integer).<br>
      <br>
Set register Rdest to 1 if register Rsrc1 is less than Src2 (or Imm) and to 0 otherwise.<br>
slt Rdest, Rsrc1, Src2: Set Less Than<br>
slti Rdest, Rsrc2, Imm: Set Less Than Immediate<br>
sltu Rdest, Rsrc1, Src2: Set Less Than Unsigned<br>
sltiu Rdest, Rsrc1, Imm: Set Less Than Unsigned Immediate<br>
      <br>
      <span style="font-weight: bold;">Branch and Jump Instructions</span><br>
In all instructions below, Src2 can either be a register or an
immediate value (integer). Branch instructions use a signed 16-bit
offset field; hence they can jump 2^15 -1 instructions (not bytes)
forward or 2^15 instructions backward. The jump instruction contains a
26-bit address field.<br>
      <br>
Conditionally branch to the instruction at the label if coprocessor z's condition flag is true(false).<br>
bczt label: Branch Coprocessor z True<br>
bczf label: Branch Coprocessor z False<br>
      <br>
Conditionally branch to the instruction at the label if the contents of register Rsrc1 equals Src2.<br>
beq Rsrc1, Rsrc2, offset: Branch on Equal<br>
      <br>
Conditionally branch to the instruction at the label if the contents of Rsrc are greater than or equal to 0.<br>
bgez Rsrc, offset: Branch on Greater Than Equal Zero<br>
      <br>
Conditionally branch to the instruction at the label if the contents of
Rsrc are greater than or equal to 0. Save the address of the next
instruction in register 31.<br>
bgezal Rsrc, offset: Branch on Greater Than Equal Zero And Link<br>
      <br>
Conditionally branch to the instruction at the label if the contents of Rsrc are greater than 0.<br>
bgtz Rsrc, offset: Branch on Greater Than Zero<br>
      <br>
Conditionally branch to the instruction at the label if the contents of Rsrc are less than or equal to 0.<br>
blez Rsrc, offset: Branch on Less Than Equal Zero<br>
      <br>
Conditionally branch to the instruction at the label if the contents of
Rsrc are greater or equal to 0 or less than 0. Save the address of the
next instruction in register 31.<br>
bgezal Rsrc, offset: Branch on Greater Than Equal Zero And Link<br>
bltzal Rsrc, offset: Branch on Less Than And Link<br>
      <br>
Conditionally branch to the instruction at the label if the contents of Rsrc are less than 0.<br>
bltz Rsrc, offset: Branch on Less Than Zero<br>
      <br>
Conditionally branch to the instruction at the label if the contents of Rsrc1 are not equal to Src2.<br>
bne Rsrc1, Src2, offset: Branch on Not Equal<br>
      <br>
Unconditionally jump to the instruction at the label.<br>
j label: Jump<br>
      <br>
Unconditionally jump to the instruction at the label or whose address
id in register Rsrc. Save the address of the next instruction in
register 31.<br>
jal label: Jump and Link<br>
jalr Rsrc: Jump and Link Register<br>
      <br>
Unconditionally jump to the instruction whose address is in register Rsrc.<br>
jr Rsrc: Jump Register<br>
      <br>
      <span style="font-weight: bold;">Load Instructions</span><br>
      Load the byte at memory address Rsrc + imm into register Rdest. The
byte is sign-extended by the lb, but not the lbu, instruction.<br>
lb Rdest, imm(Rsrc): Load Byte<br>
lbu Rdest, imm(Rsrc): Load Unsigned Byte<br>
      <br>
Load the 16-bit quantity (halfword) at memory address Rsrc + imm into
register Rdest. The halfword is sign-extended by the lh, but not the
lhu, instruction.<br>
lh Rdest, imm(Rsrc): Load Halfword<br>
lhu Rdest, imm(Rsrc): Load Unsigned Halfword<br>
      <br>
Load the 32-bit quantity (word) at memory address Rsrc + imm into register Rdest.<br>
lw Rdest, imm(Rsrc): Load Word<br>
      <br>
Load the word at memory address Rsrc + imm into register Rdest of coprocessor z (0-3).<br>
lwcz Rdest, imm(Rsrc): Load Word<br>
      <br>
Load the left (right) word at the possibly unaligned memory address Rsrc + imm into register Rdest.<br>
lwl Rdest, imm(Rsrc): Load Word Left<br>
lwr Rdest, imm(Rsrc): Load Word Right<br>
      <br>
      <span style="font-weight: bold;">Store Instructions</span><br>
Store the least significant byte of register Rsrc1 into memory address Rsrc2 + imm.<br>
sb Rsrc1, imm(Rsrc2): Store Byte<br>
      <br>
Store the lower 16 bits (halfword) of register Rsrc1 into memory address Rsrc2 + imm.<br>
sh Rsrc1, imm(Rsrc2): Store Halfword<br>
      <br>
Store the word in register Rsrc1 into memory address Rsrc2 + imm.<br>
sw Rsrc1, imm(Rsrc2): Store Word<br>
      <br>
Store the word in register Rsrc1 of coprocessor z (0-3) into memory address Rsrc2 + imm.<br>
swcz Rsrc1, imm(Rsrc2): Store Word<br>
      <br>
Store the word in register Rsrc1 into the possibly unaligned memory address Rsrc2 + imm.<br>
swl Rsrc1, imm(Rsrc2): Store Word Left<br>
swr Rsrc1, imm(Rsrc2): Store Word Right<br>
      <br>
      <span style="font-weight: bold;">Miscellaneous Instructions</span><br>
      The multiply and divide unit produces its result in two additional
registers, hi and lo. These instructions move values to and from these
registers. The multiply, divide, and remainder instructions described
above are pseudoinstructions that make it appear as if this unit
operates on the general registers and detects error conditions such as
divide by zero or overflow.<br>
      <br>
Move the contents of the hi(lo) register to register Rdest.<br>
mfhi Rdest: Move From hi<br>
mflo Rdest: Move From lo<br>
      <br>
Move the contents of the register Rdest to the hi(lo) register.<br>
mthi Rdest: Move To hi<br>
mtlo Rdest: Move To lo<br>
      <br>
Coprocessors have their own register sets. These instructions move values between these registers and the CPU's registers.<br>
      <br>
Move the contents of CPU register Rsrc to coprocessor z's register CPdest.<br>
mfcz Rdest, CPsrc: Move From Coprocessor z<br>
      <br><br>
</td><td><br>
</td></tr></tbody></table></body></html>